## 包装类中常用的操作方法
1. 包装类中的常量  
   - 最大值: MAX_VALUE
   - 最小值: MIN_VALUE
   - 内存中占的比特位数: SIZE
   - 对应的基本类型: TYPE
  
2. 包装类的构造器
- 第一种:  
  构造器参数中接收自己对应的基本类型值  
  如 `Integer(int val)`, `Boolean(bool val)`...
- 第二种:  
  构造器参数中接收的是 String 类型的值  
  但 Character 这个包装类除外, 它只有第一种构造器   
  如: `Integer(String val)`, `Boolean(String val)`...

3. 基本类型和包装类型的转换(装箱和拆箱)
- 装箱:  
  - `Integer i1 = new Integer(111);`
  - `Integer i2 = Integer.valueOf(111);`
  - 推荐使用第二种, 因为这种方式带有缓存
- 拆箱:  
  - `int val = i1;`
- 数据类型间的转换:  
  - 由于 Number 类是 Byte Short Long Integer Float 和 Double 类的父类  
    因此, 这 6 个包装类都会从 Number 类中继承到一些方法  
    Number 类中带有这六种类型中任意包装类对象转换成任意基本数据类型的方法
  - 转换方法:  
  
    基本数据类型| 包装类对象调用的方法  
    -|-  
    byte| byteValue
    short| shortValue
    long| longValue
    int| intValue
    float| floatValue
    double| doubleValue

4. String 和基本类型/包装类型之间的转换操作
   **不论用哪种方式进行转换, 输入的字符串必须能转换成数字**
   - 把 String 转换为包装类对象
     - 方式 1:   
       valueOf 方法, 将 String 转换为对应的包装类对象  
       如: `Integer i1 = Integer.valueOf("123");`
     - 方式 2:  
       直接新建对象传参即可  
       如: `Integer i2 = new Integer("123");`
   - 把基本数据类型转换为 String
     - `String s1 = 18 + "";`
   - 把包装类对象转换为 String
     - `String str = 任何对象.toString();`
   - 把 String 转换为基本数据类型
     - parseXXX 方法, XXX 表示八大基本数据类型


## 包装类的缓存设计(享元模式)
**在使用 valueOf 方法去创建包装类对象时会产生缓存**
- Byte, Short, Integer, Long:  
  缓存范围为 [-128, 127) 区间的数据.
- Character:  
  缓存[0, 127) 区间的数据

- 示例:  
  - 在缓存范围内, 创建相同值的对象会自动抓取缓存,  
    因此两次创建的对象是同一对象
    ```java
    Integer i1 = Integer.valueOf("123");
    Integer i2 = Integer.valueOf("123");
    System.out.println(i1==i2)// 结果为true
    ```
  - 在缓存范围外, 创建相同值的对象不会产生缓存,  
    因此两次创建的对象并非同一对象
    ```java
    Integer i3 = Integer.valueOf("270");
    Integer i4 = Integer.valueOf("270");
    System.out.println(i3==i4)// 结果为false
    ```
- 备注:  
  - 若要对超出缓存范围外的包装类对象数值进行比较  
    可使用 equals 方法.
    如: 
    ```java
    Integer i11 = 255;
    Integer i22 = 255;
    System.out.println(i11.equals(i22))// 结果为true
    ```
  - 因此包装类型对象间的比较操作一律建议使用 equals 方法进行比较,  
    因为比较的是包装的数据, 而非对象本身的地址.