<!-- TOC -->

- [1. 线程通信中的死锁](#1-线程通信中的死锁)
  - [1.1. 死锁的产生](#11-死锁的产生)
  - [1.2. 避免死锁的法则](#12-避免死锁的法则)
  - [1.3. Thread 类中的过时方法](#13-thread-类中的过时方法)

<!-- /TOC -->

## 1. 线程通信中的死锁
- 多线程通信的时候很容易造成死锁, 死锁无法解决, 只能避免.

### 1.1. 死锁的产生  
- 当 A 线程等待由 B 线程持有的锁, 而 B 线程正在等待 A 线程持有的锁时,  
  会发生死锁现象, JVM 不会去检测或避免死锁, 所以必须在编写的时候规避.

### 1.2. 避免死锁的法则  
- 当多个线程都要访问共享资源 A/B/C 时, 保证每个线程都按照  
  相同的顺序去访问它们, 比如都先访问 A, 接着 B, 最后 C.

### 1.3. Thread 类中的过时方法
- `suspend()` 方法:  
  使正在运行的线程放弃 CPU, 暂停运行.

- `resume()` 方法:  
  使暂停的线程恢复运行.

- 过时原因:  
  因为容易导致死锁, 因此被废弃.

- 死锁原因:  
  假设 A 线程获得了对象锁, 同时在执行一个同步方法,  
  而此时 B 线程调用 A 线程的 `suspend()` 方法暂停 A 线程,  
  因此 A 线程会暂停运行并放弃 CPU, 但 A 线程不会释放同步锁.  
  因此造成了死锁, 导致 B 线程无法在后续执行过程中获取同步锁.  
