<!-- TOC -->

- [1. 线程控制操作](#1-线程控制操作)
  - [1.1. 线程休眠](#11-线程休眠)
  - [1.2. 联合线程](#12-联合线程)
    - [1.2.1. 联合线程实例:](#121-联合线程实例)
  - [1.3. 后台线程](#13-后台线程)
    - [1.3.1. 后台线程的特点](#131-后台线程的特点)
    - [1.3.2. 设置和检测后台线程的方式](#132-设置和检测后台线程的方式)

<!-- /TOC -->

## 1. 线程控制操作

### 1.1. 线程休眠
- 线程休眠会让执行的线程暂停一段时间, 进入计时等待状态.

- 通常会进行调用的方法是 `static void sleep(long mills)`  
  该方法位于 `java.lang.Thread` 当中, 是线程对象方法.

- 调用 `sleep()` 方法后, 当前线程放弃 CPU, 并在指定时间段内,  
  该调用 `sleep()` 方法的线程会进入等待池且不会获得执行的机会,  
  不过在此状态下, 睡眠的线程是不会释放同步锁/同步监听器的.

- 该方法通常用于模拟网络延迟, 让多线程并发访问同一个资源的错误效果更明显.   

### 1.2. 联合线程
- 线程的 `join()` 方法表示一个线程等待另一个线程完成后才执行.  
  
- `join()` 方法被插入的线程对象调用之后, 原线程对象会处于阻塞状态,  
  直到插入的线程执行完毕后, 原线程才会恢复运行.

- 称为联合线程是因为可以把调用 `join()` 方法的线程对象  
  和包含该线程对象的方法所属的线程对象联合在一起.

#### 1.2.1. 联合线程实例:  
- 将在主线程中插入一个新线程.  
  ```java
  class Join extends Thread {
      public void run() {
          for (int i = 0; i < 5; i++) {
              System.out.println("join:" + i);
          }
      }
  }

  public class Test {
      public static void main(String[] args) throws InterruptedException {
          Join joinThread = new Join();
          System.out.println("main begin");
          for (int i = 0; i < 5; i++) {
              System.out.println("main:" + i);
              if (i == 2) {
                  joinThread.start();
                  joinThread.join();
              }
          }
          System.out.println("main end");
      }
  }
  ```

- 效果图示:  
  如下图所示, 原主线程将会在插入线程执行完毕后, 再继续执行.  
  ![pic](../99.images/2021-01-09-15-54-25.png)


### 1.3. 后台线程
- 指的是在后台运行的线程, 其目的是为其它线程提供服务, 也被称作"守护线程".
- JVM 的垃圾回收线程就是典型的后台线程.

#### 1.3.1. 后台线程的特点
- 若所有的前台线程都死亡, 后台线程自动死亡;
- 若仍有前台线程没有结束, 后台线程也不会结束.

#### 1.3.2. 设置和检测后台线程的方式
- 检测线程对象是否为后台线程的方法:  
  - 使用 `Thread.isDaemon()` 方法.

- 前台线程创建新线程默认是前台线程, 可通过 `setDaemon()` 方法设为后台线程.  
- 同时当且仅当后台线程创建新的线程时, 新线程才是后台线程.

- 设置后台线程的方法:  
  - 令线程对象调用 `Thread.setDaemon(true)` , 参数为 `true`.
  - 调用 `setDaemon()` 方法必须在调用 `start()` 方法之前进行,  
    否则将会出现 `IllegalThreadStateException` 异常提示.