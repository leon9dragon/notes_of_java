## 抽象方法
- 定义:  
  - 使用 abstract 关键字修饰且没有方法体的方法, 称作抽象方法
    - 示例   
      如下所示, 在抽象类中定义了抽象方法.
      ```java
      abstract public class Test{
          abstract public void SayHi();
      }
      ```
- 特点:  
  - 使用抽象 abstract 修饰, 方法没有方法体,  
    留给子类去实现, 且子类也必须要对其覆盖实现   
  - 抽象方法修饰符不能是 private 和 final 以及 static  
    因为抽象方法必须要被子类继承覆盖修改, 且供子类对象调用
  - 抽象方法必须定义在抽象类或接口中
- 备注:  
  - 一般来说, 习惯性把 abstract 写在方法修饰符最前面

## 抽象类
- 定义:  
  - 使用 abstract 关键字修饰的类
- 特点:  
  - 不能创建实例, 即不能创建抽象类对象  
    因为即使创建出抽象类对象, 也根本不能调用抽象方法,  
    因为抽象方法没有方法体
  - 可以不包含抽象方法, 若一旦包含, 该类必须作为抽象类  
    抽象类中可以存在普通方法, 是留给子类调用的.
  - 若子类没有实现父类所有抽象方法,  
    那么子类也得作为抽象类(抽象派生类)  
  - 构造方法都不能定义成私有的, 否则不能有子类,  
    因为创建子类对象前会先调用父类的构造方法
  - 抽象类不能被 final 修饰,  
    因为必须有子类, 抽象方法才能得以实现,   
    否则抽象类定义并无意义
- 总结:  
  - 抽象类是不完整的类, 需要作为父类, 通过其子类才能实现它的功能, 因此没有子类的抽象类是没有意义的.
  - 一般抽象类起名都用 Abstract 作为名字前缀.
  - 抽象类中可以不存在抽象方法, 如此操作意义不大.   
    但可防止外界创建对象, 可作工具类使用.


## 抽象类和普通类的区别
- 普通类有的成员(方法,字段,构造器), 抽象类都有
- 抽象类不能创建对象, 抽象类可以包含抽象方法

## 抽象类和多态的区别
- 多态可以由父类创建对象, 实际可以指向它的子类,  
  使得由父类创建的对象可以根据实际使用时指向不同子类,  
  从而使用不同子类中的方法.

- 抽象类不可以由父类创建对象, 抽象类的实现必须通过子类.
  抽象方法实现必须通过具体的子类来创建对象从而调用方法.

## 抽象类中的构造器
- 如果抽象类中存在构造器, 那么子类也会对其进行调用.  
  子类继承父类,会将父类的成员变量继承下来.  
  使用 super 调用父类构造的作用是初始化子类对象中继承自父类的属性.  
  而不是创建子类对象的同时也创建了一个父类对象

- 抽象类不能进行创建实例指的是不能直接调用抽象类的构造函数进行初始化对象.  
  - 例如存在抽象父类 `abstract public class Father{...}`,  
    假设其构造器为 `public Father(){...}`,  
    然后在创建实例的时候 `Father sample = new Father();`   
    这样创建是会报错的, 因为直接调用了父类构造函数, 是不合理的.  
  
  - 那么, 假设存在子类 `public class Son extends Father{...}`,  
    假设其构造器为 `public Son(){...}`,  
    然后在创建实例的时候 `Father sample = new Son();`  
    这样创建就不会报错, 因为调用的是子类的构造函数,  
    从而形成了抽象类的多态.