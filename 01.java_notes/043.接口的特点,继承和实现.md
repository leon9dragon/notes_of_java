## 接口的特点
1. 没有构造方法, 不能实例化
2. 接口只能继承接口, 不能继承类, 且接口支持多继承  
   示例:  
   `[修饰符] interface 接口名 extends 接口1, 接口2`
3. 接口里的方法全是抽象的,  
   默认修饰符是 `public abstract`
4. 接口里的字段全是全局静态常量,  
   默认修饰符是 `public static final`
5. 接口里的内部类全是静态的,  
   默认修饰符是 `public static`

## 接口和接口/接口和类间的关系
- 接口和接口之间只能是继承关系, 用 extends 来表示
- 接口和实现类之间只能是实现关系, 用 implements 来表示  
  且一个类可以实现多个接口, 弥补了类只能单继承的问题.
  示例:  
```java
   [修饰符] class 类名 extends 父类 implements 接口1, 接口2{
      //实现类的实现内容
   }
```
- 因此可以认为接口是实现类的父类, 实现类就是接口的子类  
- 因此 `接口 变量 = new 实现类对象` 则体现了多态思想  
- 接口和实现类的多态关系是使用的最多的

## 接口的实现关系
- **接口的实现者: 实现类**
  - 接口仅仅只定义了某一类事物应该具有某些功能, 但没有提供实现
  - 接口需要用户去提供实现类去覆盖接口中的方法, 从而实现接口所规定的功能
  - 注意:  
    - 接口中的方法是公共抽象的, 所以实现类必须覆盖接口中的方法,  
    并且方法必须使用 public 修饰,   
    因为子类覆盖的访问权限必须大于等于父类
    - 若一个类同时实现了多个接口, 如下:  
      用什么接口来实例化实现类对象, 只能调用该接口下存在的方法
      若是想要调用该类实现的全部方法, 只能用本类来实例化对象
      ```java
      public interface Meat{
         void getMeat();
      }
      public interface Vegetable{
         void getVegetable();
      }
      public class Food implements Meat, Vegetable{
         public void getMeat(){
            System.out.println("Get some meat");
         }
         public void getVegetable(){
            System.out.println("Get some vegetable");
         }
      }
      public class TestDemo{
         public static void main(String args[]){
            /*-------------------------*/
            Meat m = new Food();
            m.getMeat();
            /*-------------------------*/
            Vegetable v = new Food();
            v.getVegetable();
            /*-------------------------*/
            Food f = new Food();
            f.getMeat();
            f.getVegetable();
         }
      }
      ```